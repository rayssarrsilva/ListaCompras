Quando estiver usando Docker, nÃ£o rode flask run, uvicorn main:app, python app.py nem nada local.

apenas docker compose up ou docker compose up --build

---
garantir que:

local = usa .env.local (ou o prÃ³prio .env)

docker = usa .env.docker ou variÃ¡veis definidas no compose, porque dentro do Docker o host NUNCA Ã© localhost
errado p docker: DATABASE_URL=postgresql://postgres:123@localhost:5432/meubanco
certo: postgres://postgres:123@db:5432/meubanco
---
Docker nÃ£o vai usar o seu PostgreSQL local
Dentro do Docker, o app sÃ³ enxerga o banco rodando dentro do Docker, nÃ£o o da sua mÃ¡quina. 

VocÃª vai ter:

um PostgreSQL local, instalado na mÃ¡quina
um PostgreSQL dentro do Docker (container)
talvez atÃ© um PostgreSQL na AWS RDS no futuro
---
Se vocÃª mudar arquivos no seu projeto e eles nÃ£o refletirem dentro do Docker, provavelmente vocÃª esqueceu:
volumes:
  - .:/app
isso Ã© Ãºtil no desenvolvimento, e perigoso em produÃ§Ã£o.
 verificar isso  quando criar docker-compose.yml.
 ---
 portas
 Flask â†’ geralmente porta 5000
FastAPI â†’ geralmente porta 8000
PostgreSQL â†’ porta 5432

Se sua mÃ¡quina jÃ¡ tiver:
PostgreSQL local rodando na 5432

O container vai falhar ao iniciar o serviÃ§o db
SoluÃ§Ã£o: trocar a porta externa: 5433:5432
---
O pytest precisa rodar dentro do container, nÃ£o local

Porque:

local = usa Python local + dependÃªncias locais
docker = usa Python docker + libs docker

Se vocÃª rodar: pytest, Ele pega o ambiente errado. O certo Ã©: docker compose exec app pytest
---
Quando vocÃª estiver com Docker + PostgreSQLâ€¦ NADA local deve mexer no banco

Por quÃª?

Se vocÃª rodar local e docker ao mesmo tempo: CORROMPE O BANCO
Se vocÃª rodar migraÃ§Ãµes local e depois docker: INCONSISTÃŠNCIA

regra:
docker compose up   â†’ usa banco docker
python local        â†’ usa banco local
---
Testes com pytest NÃƒO vÃ£o acessar seu banco local
Ã‰ que vocÃª deve escolher um ambiente Ãºnico para o banco (local OU Docker) e nÃ£o misturar.
Se optar por Docker, tudo (FastAPI, Flask, migrations, testes) deve conversar com o banco do container.

Configure seu .env para apontar para o banco do Docker (DATABASE_URL=postgresql://... com host do container).
Rode docker compose up para subir Postgres + sua API.
FaÃ§a testes/migraÃ§Ãµes sempre dentro desse ambiente.

Eles vÃ£o acessar o banco do container de test.

Ou vocÃª usa:

um PostgreSQL separado para testes

ou um SQLite isolado (mais simples)

ou um "schema de teste" limpo no mesmo container

ğŸ“Œ Quando chegarmos nos testes, me lembre de revisar com vocÃª o conftest.py.

2. Configurar no pgAdmin
Abra o pgAdmin â†’ Add New Server â†’ preencha:

Name: qualquer nome (ex: Postgres Docker)

Host:

localhost se vocÃª mapeou a porta para sua mÃ¡quina

ou o nome do serviÃ§o (db) se estiver usando docker compose

Port: 5432 (ou a porta que vocÃª expÃ´s)

Username: postgres (ou o usuÃ¡rio que vocÃª definiu)

Password: a senha que vocÃª passou no POSTGRES_PASSWORD
---
Logs e erros no Docker sÃ£o diferentes
Docker:
docker compose logs app
-----
âœ” 5. pytest vai rodar no backend via Docker

O comando serÃ¡:

docker compose exec backend pytest


E seus testes vÃ£o usar o PostgreSQL Docker, nÃ£o o da sua mÃ¡quina.